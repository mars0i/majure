I'm using MASON, a library for agent-based simulations that's written in
Java.  gen-class allows me to write Clojure "classes" that
extend/implement the classes provided by MASON.  The resulting code is
more Java-esque and less Clojurely than I'd like, but it works.

However, in the example I'm exploring, a simple Clojure simulation is
170 times slower than the same simulation in pure Java.  If I carefully
add type hints, I can make the Clojure version (roughly) twice as slow
as Java.  Yayy type hints!

In order to use type hints, I had to reorganize the code a little bit to
get rid of cyclic dependencies, but there's one remaining cyclic
dependency.  My StudentsSimState class has to be compiled before my
Student class, and vice versa.  (I get a class not found error--not a
cyclic dependency error.) As far as I can see, there is no way to avoid
this cycle given MASON's design and intended use.  I've solved the
problem by deleting a type hint, compiling all of the source files, then
adding back the type hint in one location and recompiling that file.  I
could automate this process with a shell script, but it's obviously an
ugly solution.

Why there's a cyclic dependency:

MASON simulations typically consist of 
(a) One or more "agents", which implement an interface (Steppable) with
a single method, step().
(b) An instance of a class that extends SimState, which contains a
scheduler that repeatedly calls step() in every agent that's registered
with it.

The agents have to interact with each other, and the way that they find
out about eachothers' states is through the the SimState object that's passed to
step().  The type hint that I delete and restore is the second one here:

(defn -step [^students.Student this ^students.StudentsSimState students]

I know that cyclic dependencies are considered harmful in the Clojure
world, and I can understand that they *can* lead to confusion.  But
MASON's organization seems perfectly reasonable for an agent-based
simulation intended for use with Java.  There are no Clojure ABM
libraries, and it's reasonable for me to want to use MASON with Clojure.

Clojure lets me do this using gen-class (and occasional use of proxy),
and in fact there is no problem at all with cyclic dependencies if I
don't add type hints.  It's only when I want to optimize my code with
type hints that I end up having to do wierd things with my code and
compilation process.  That seems like an arbitrary limitation on
Clojure's otherwise very flexible interoperability functionality.

I *don't* think that Clojure should incorporate every feature that
someone thinks they want, and certainly don't think that it should
provide every feature allowed by Java.  What I like about Clojure is its
flexible, simple, well-thought out elegance.

But the ban on cyclic dependencies is not the absence of a language
feature.  It's an arbitrary limitation due to the way that Clojure is
compiled.  Allowing cyclic dependencies wouldn't make Clojure any less
simple or elegant, because it doesn't really add anything to the language.
In fact, cyclic relationships are already allowed in Clojure--as long as
they are determined at runtime.  It's only the compiler that can't figure
them out in advance.  That's true in general, not just when interacting
with Java, but it also seems like an arbitrary limitation.

As for the possibility that people will abuse cyclic dependencies and
create complex code, well, we already have a strong coding style
culture.  It can be used to teach people to avoid cycles whenever
possible.  (Note that newbies repeatedly ask "How can I do this
idomatically" on StackOverflow.)
